## 1\. 多请求下 loading 的显示与隐藏

在 vue 中一般会搭配 axios 做全局的请求方法，在拦截器中利用第三方组件控制 loading 展示和关闭，代码是这样的：

```js
// 请求拦截器
axios.interceptors.request.use(
  (config) => {
    Toast.loading({
      message: '加载中...',
      forbidClick: true,
      loadingType: 'spinner',
    });
    return config;
  },
  (error) => {
    return Promise.error(error);
  },
);

// 响应拦截器
axios.interceptors.response.use(
  (response) => {
    Toast.clear();
    if (response.status === 200) {
      return Promise.resolve(response);
    } else {
      return Promise.reject(response);
    }
  },
  (error) => {
    console.log('error', error);
    Toast.clear();
    if (error.response.status) {
      switch (error.response.status) {
        default:
          this.$toast({ message: '未知系统异常', time: 2000 });
      }
      return Promise.reject(error.response);
    }
  },
);
```

在多个请求的情况下，依照上面的设置方法，loading 在频繁的打开与关闭，会造成 loading 的闪烁，加载完成的真实时间可能被影响，造成用户体验不好。

下面的是解决方案，请求的数量做一个全局的变量，初始值为 `0`，请求进入的时候 `+1`,请求被成功响应的时候 `-1`,当请求数量未 0 再没有需要请求的内容，loading 关闭，在这里 loading 的初始时间可以设置的稍长一些。同时，应当在请求错误与路由切换的时候做 归零操作，隐藏 loading，reset。

```js
export default class loadingControl {
  constructor() {
    this.isShowLoading = true;
    this.loadingCount = 0;
  }
  addLoading = () => {
    this.isShowLoading = true;
    this.loadingCount++;
  };
  isCloseLoading() {
    this.loadingCount--;
    if (this.loadingCount == 0) {
      this.isShowLoading = false;
    }
  }
 reset() {
    this.loadingCount = 0;
    this.isShowLoading = false;
  }
}
```

```js
import loadingControl from './loadingControl';
const LOADING = (window.LOADING = new loadingControl());

// 请求拦截器
axios.interceptors.request.use(
  (config) => {
    LOADING.addLoading();
    Toast.loading({
      message: '加载中...',
      forbidClick: true,
      loadingType: 'spinner',
      duration: 10000,
    });
    return config;
  },
  (error) => {
    return Promise.error(error);
  },
);

// 响应拦截器
axios.interceptors.response.use(
  (response) => {
    LOADING.isCloseLoading();
    console.log('剩余请求数量', LOADING.loadingCount);
    LOADING.loadingCount === 0 ? Toast.clear() : '';
    if (response.status === 200) {
      return Promise.resolve(response);
    } else {
      return Promise.reject(response);
    }
  },
  (error) => {
    LOADING.reset();
    Toast.clear();
    console.log('error', error);
    if (error.response.status) {
      switch (error.response.status) {
        default:
          this.$toast({ message: '未知系统异常', time: 2000 });
      }
      return Promise.reject(error.response);
    }
  },
);
```

```js
 // 路由改变，重置 loading
 window.LOADING.reset();
```

单个页面控制，使用 promise 扩展

```js
    Promise.every([
      this.getArticleList(),
      this.getVideoList(),
      this.getKnowList(),
      this.getMessageList(),
    ]).then(([...res]) => {
      this.setData({
        ...res[0],
        ...res[1],
        ...res[2],
        ...res[3],
        isLoading: false,
      });
    });
```

## 2\. 保留用户阅读位置

```js
import { debounce } from '@/utils';
export default class RememberScroll {
  constructor() {
    this.readList = [];
    this.limit = 10;
  }
  async init() {
    // 纪录位置
    await this.isScroll();
    this.listenScrollEvent();
  }
  async isScroll() {
    let $ReadList = this.readList;
    let path = window.location.href;
    let selected = $ReadList.filter((v) => v.path === path);

    if (selected.length === 1) {
      console.log('已经阅读过', selected);
      await setTimeout(() => {
        window.scrollTo(0, selected[0].top);
      }, 200);
    }
  }
  scrollTo(x, y) {
    window.scrollTo(x, y);
  }
  insertReadList(scrollTop) {
    let path = window.location.href;
    let $ReadList = this.readList;
    let $Limit = this.Limit;
    let obj = {
      path,
      top: scrollTop,
    };
    let selected = $ReadList.filter((v) => v.path === path);
    if (selected.length === 0) {
      if ($ReadList.length >= $Limit) {
        // console.log('超量了');
        $ReadList.pop();
        $ReadList.unshift(obj);
      }
        $ReadList.unshift(obj);
    } else {
      selected[0].top = scrollTop;
    }
    // console.log('缓存的阅读列表',$ReadList);
  }
  listenScrollEvent() {
    const listenFn = debounce(() => {
      const scrollTop =
        document.documentElement.scrollTop || document.body.scrollTop;
      this.insertReadList(scrollTop);
    }, 200);
    window.addEventListener('scroll', listenFn);
  }
}
```

## 3\. 按钮点击频发

## 4\. 点赞收藏，购物车增加删除 及时反馈

## 5\. 移动端调试工具预留 eruda

```html
 <script>
      (function () {
        var src = 'https://cdn.bootcss.com/eruda/1.4.3/eruda.min.js';
        // 默认开启调试
        //     localStorage.setItem('ERUDA_DEV', true);
        /*      if (
          localStorage.getItem('ERUDA_DEV') != 'true' &&
          sessionStorage.getItem('ERUDA_DEV') != 'true'
        )
          return;*/
        document.write('<scr' + 'ipt src="' + src + '"></scr' + 'ipt>');
        document.write('<scr' + 'ipt>eruda.init();</scr' + 'ipt>');
      })();
    </script>
```

## 6\. 1px 像素

```css
.cus-border-bottom {
  position: relative;
}
.cus-border-bottom::after {
  content: ' ';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 1px;
  transform: scale(1, 0.5);
  transform-origin: left top;
  box-sizing: border-box;
  border-bottom: 1px solid #cccccc;
}

.cus-border-all {
  position: relative;
}
.cus-border-all::after {
  content: ' ';
  position: absolute;
  top: 0;
  left: 0;
  width: 200%;
  height: 200%;
  transform: scale(0.5);
  transform-origin: left top;
  box-sizing: border-box;
  border: 1px solid #cccccc;
}
```

## 7\. promise 扩展

Promise.all 错误处理，使用 every 方法，所有的 promise 都错误才触发 reject

```js
Promise.every = promiseAry => {
  return new Promise((resolve, reject) => {
    let resultAry = [],
      errorAry = [],
      index = 0,
      index__error = 0;
    for (let i = 0; i < promiseAry.length; i++) {
      Promise.resolve(promiseAry[i])
        .then(result => {
          index++;
          resultAry[i] = result;
          if (index === promiseAry.length) {
            resolve(resultAry);
          }
        })
        .catch(reason => {
          index__error++;
          index++;
          errorAry[i] = reason;
          if (index__error === promiseAry.length) {
            reject(errorAry);
          }
        });
    }
  });
};
```

## 8\. 为 localStorage 设置缓存过期时间

```js
class StorageFn {
  constructor() {
    this.ls = window.localStorage;
  }
  setItem(key, val, expires) {
    // 设置过期时间 https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/171
    if (typeof expires !== 'undefined') {
      var expiresDate = new Date(expires).valueOf();
      this.ls.setItem(key + '_expires', expiresDate);
    }
    this.ls.setItem(key, val);
  }

  getItem(key) {
    var expires = this.ls.getItem(key + '_expires');
    if (expires && new Date() > new Date(Number(expires))) {
      this.ls.removeItem(key);
      this.ls.removeItem(key + '_expires');
    }
    if (key) return this.ls.getItem(key);
    return null;
  }

  removeItem(key) {
    this.ls.removeItem(key);
  }

  /*移除所有localStorage*/
  clear() {
    this.ls.clear();
  }
}
```

```js
const Storage = new StorageFn();
Storage.setItem('key', 'value', new Date(Date.now() + 10000)); // 10 秒钟后过期
Storage.getItem('key');
```

```js
(function() {
  var getItem = localStorage.getItem.bind(localStorage);
  var setItem = localStorage.setItem.bind(localStorage);
  var removeItem = localStorage.removeItem.bind(localStorage);
  localStorage.getItem = function(keyName) {
    var expires = getItem(keyName + '_expires');
    if (expires && new Date() > new Date(Number(expires))) {
      removeItem(keyName);
      removeItem(keyName + '_expires');
    }
    return getItem(keyName);
  };
  localStorage.setItem = function(keyName, keyValue, expires) {
    if (typeof expires !== 'undefined') {
      var expiresDate = new Date(expires).valueOf();
      setItem(keyName + '_expires', expiresDate);
    }
    return setItem(keyName, keyValue);
  };
})();
```

#### 参考

-   [多个请求下 loading 的展示与关闭](https://github.com/woai3c/Front-end-articles/blob/master/control%20loading.md)